# Counting Sort
1st Writter : Hod0ri
  
## Scope
계수 정렬 (Counting Sort)는 이전 정렬 알고리즘과는 다르게, 원소간의 비교를 하지 않고 정렬하는 알고리즘이다.  
그러하여, 아무 데이터를 계수 정렬을 통해 정렬 할 수 없으며, 아래와 같은 조건을 따르는 데이터만 본 정렬을 사용할 수 있다.  
1. 리스트 내 모든 원소 k는 k >= 0 인 정수이다.  
2. k = O(n)으로 표현이 가능해야 한다.  
  
보통 범위가 주어진 배열에서 퀵, 힙 정렬보다도 빠르게 정렬을 요구할 때 사용이 된다.  
```py
# 예시 
arr = [1, 0, 0, 0, 2, 2, 1, 1, 3, 4, 2, 1, 5]
# 0이상, 5이하의 원소가 담긴 배열 arr을 정렬하시오
```

## Theory
원리는 아주 간단하다.
위 배열을 예시로 해당 배열에 각 숫자가 몇번 나오는 지 확인해보자.
```
0 : 3개
1 : 4개
2 : 3개
3 : 1개
4 : 1개
5 : 1개
```
이렇게 정렬이 된 이후, 작은 수 부터 큰 수까지 그대로 나열해보면
```py
[0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 3, 4, 5]
```
이제 생각을 조금 바꿔서 각 숫자를 인덱스로 생각하면 끝난다.
표로 구성하여 다시 확인해보자.

|Index|0|1|2|3|4|5|6|7|
|---|---|---|---|---|---|---|---|---|
|Element|5|5|3|4|2|0|1|2|

이러한 배열이 있다고 가정하고, 0부터 최댓값인 5까지의 숫자 중 각 원소가 몇번 등장하는지 셈을 한다.

|Element|0|1|2|3|4|5|
|---|---|---|---|---|---|---|
|Count|1|1|2|1|1|2|

그 다음, 횟수를 누적합으로 변경한다.

|Element|0|1|2|3|4|5|
|---|---|---|---|---|---|---|
|Sum|1|2|4|5|6|8|

이때, 누적합과 셈에 관한 배열을 살펴 보면,  
0은 인덱스가 1인 자리에 위치함을 알 수 있다.

|Index|0|1|2|3|4|5|6|7|
|---|---|---|---|---|---|---|---|---|
|Element|0|1|2|2|3|4|5|5|

## Code Review
|Language|Writer|
|---|---|
|[C/C++](https://github.com/Hod0ri/Algorithm_Semina/blob/main/Counting%20Sort/CodeReview_cpp.md)|Hod0ri|

## Complex
최대 원소의 크기와 배열의 크기에 따라서 생성되어야 할 추가적인 배열의 크기가 커지기 때문에, 메모리의 영향을 받는다. 
