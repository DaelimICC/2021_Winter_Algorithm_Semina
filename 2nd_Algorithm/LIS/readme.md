# 최장 증가 부분 수열 (LIS)
N개의 원소를 가진 배열의 일부 원소를 골라 만든 부분 수열  
각 원소가 이전 원소보다 크다는 조건을 만족하고, 그 길이가 최대인 부분 수열  

##### 수열
나열 된 수의 집합
##### 증가 수열
수열의 원소들이 오름차순으로 정렬된 수열
##### 부분 수열
수열의 원소들로 구성할 수 있는 모든 수열
##### 최장 증가 부분 수열
부분 수열 중, 길이가 가장 긴 증가 수열

### LIS의 길이 구하기
![image](https://user-images.githubusercontent.com/65306839/150145406-8ca5ae69-50a9-41a7-b58a-b57288adaf74.png)  
<br />
##### DP 방식
1. 임의의 배열 A와 크기가 동일한 배열 D 생성
2. 해당 배열의 모든 원소를 1로 할당
3. O(n)방식으로 순회하면서 값을 비교
4. 원소가 작은 경우, D의 값을 증가
5. D배열의 최댓값 환산 == LIS의 길이

##### Binary Search 방식
1. 임의의 수열에 첫번째 값을, 임시 배열의 첫번째 공간에 할당한다.
2. 다음 수를 현재에 있는 값과 비교하여 클 경우, 할당하며 아닌 경우, 하한선을 찾아 대입한다.

### writer Tasty-Programmer
백준 알고리즘 문제풀이 준비했습니다!
2631번 줄세우기

### 문제
KOI 어린이집에는 N명의 아이들이 있다. 오늘은 소풍을 가는 날이다. 선생님은 1번부터 N번까지 번호가 적혀있는 번호표를 아이들의 가슴에 붙여주었다. 선생님은 아이들을 효과적으로 보호하기 위해 목적지까지 번호순서대로 일렬로 서서 걸어가도록 하였다. 이동 도중에 보니 아이들의 번호순서가 바뀌었다. 그래서 선생님은 다시 번호 순서대로 줄을 세우기 위해서 아이들의 위치를 옮기려고 한다. 그리고 아이들이 혼란스러워하지 않도록 하기 위해 위치를 옮기는 아이들의 수를 최소로 하려고 한다.

예를 들어, 7명의 아이들이 다음과 같은 순서대로 줄을 서 있다고 하자.

3 7 5 2 6 1 4

아이들을 순서대로 줄을 세우기 위해, 먼저 4번 아이를 7번 아이의 뒤로 옮겨보자. 그러면 다음과 같은 순서가 된다.

3 7 4 5 2 6 1

이제, 7번 아이를 맨 뒤로 옮긴다.

3 4 5 2 6 1 7

다음 1번 아이를 맨 앞으로 옮긴다.

1 3 4 5 2 6 7

마지막으로 2번 아이를 1번 아이의 뒤로 옮기면 번호 순서대로 배치된다.

1 2 3 4 5 6 7

위의 방법으로 모두 4명의 아이를 옮겨 번호 순서대로 줄을 세운다. 위의 예에서 3명의 아이만을 옮겨서는 순서대로 배치할 수가 없다. 따라서, 4명을 옮기는 것이 가장 적은 수의 아이를 옮기는 것이다.

N명의 아이들이 임의의 순서로 줄을 서 있을 때, 번호 순서대로 배치하기 위해 옮겨지는 아이의 최소 수를 구하는 프로그램을 작성하시오.
### Input
첫째 줄에는 아이들의 수 N이 주어진다. 둘째 줄부터는 1부터 N까지의 숫자가 한 줄에 하나씩 주어진다. N은 2 이상 200 이하의 정수이다.
### output
첫째 줄에는 번호 순서대로 줄을 세우는데 옮겨지는 아이들의 최소 수를 출력한다.

#### 풀었던 방법 및 고안한점

DP 방식으로 풀어야 할지 LIS 알고리즘을 통해서 쉽게 풀어야 할지 생각해보고 나왔던 결과는 LIS 였습니다!
백준의 다른 LIS 문제와 푸는 방식은 비슷하다고 생각하시면 편할듯 싶습니다!

2포인터를 사용해서 현재의 위치와 이전 위치 비교 하는 방식으로 비교하시면 될것같습니다~

먼저 dp[0] 은 1로 초기화 해주고 
for i in range(1,n):
    for j in range(0,i):
      if arr[i] > arr[j]:
     i는 현재값, 비교하는 부분의 값은 이전의 값들인 j= 0~i-1 입니다
     만약 j 의 값이 i의 값보다 작다면 증가하는 부분수열이 가능할것같습니다
     그렇다면 j의 dp값에 1칸 더한 것 만큼 길이가 길어지는것이 가능하다는 의미겠죠?
     따라서 j 의 dp의 최대값을 구한 후 그 값에 1을 더해서 dp[i] 에 대입합니다!
     이런식으로 재귀 혹은 반복을 통해서 최대 값을 찾는 코드를 짜보았습니다~


### source Code
```
import sys
from collections import deque
input=sys.stdin.readline


if __name__ == "__main__":
   n=int(input())
   arr=[int(input()) for _ in range(n)]
   dp=[0 for _ in range(n)]
   dp[0]=1
   MAX=0
   for i in range(1,n):
      for j in range(0,i):
         if arr[i] > arr[j]:
            MAX = max(MAX,dp[j])
      dp[i]=MAX+1
      MAX=0
   print(n-max(dp))
```
