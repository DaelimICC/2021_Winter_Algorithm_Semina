# LCA(Lowest Common Ancestor) 최소 공통 조상

## 최소공통조상(LCA)이란?
~~~
두 노드의 공통된 조상 중에서 가장 가까운 조상을 찾는 알고리즘
~~~

## 최소 공통 조상(LCA) 알고리즘
~~~
1. 모든 노드에 대한 깊이(depth)를 계산한다.
2. 최소 공통 조상을 찾을 두 노드를 확인한다.
  - 먼저 두 노드의 깊이(depth)가 동일하도록 거슬러 올라간다.
  - 이후에 부모가 같아질 때까지 반복적으로 두 노드의  부모방향으로 거슬러 올라간다.
3. 모든 LCA(a,b) 연산에 대하여 2번의 과정을 반복한다.
~~~

# Problem Case

## Solution #1 길이 맞추기 (노드가 루트까지의 길이가 짧은 경우)
~~~
예를 들어 두개의 노드가 부모 노드까지 길이가 다를 때 서로 한 단계씩 올라가면서 비교 한다면 서로 어긋나니까 우선 두 노드의 길이를 맞춰줘야 한다.

공통된 부모가 어딘지 모르는 상황이니 노드에서부터 루트까지의 길이를 구해준다.

루트까지의 길이가 긴 노드와 짧은 노드의 차이를 계산하고, 루트까지의 길이가 긴 노드에서 그 차이만큼 올라간다.

이제 길이는 맞춰졌으니 두 노드를 서로 비교해가면서 올라간다.

올라가다 같은 노드를 가리킨다면 그 노드가 공통 부모가 되는 것이다.
~~~

## Solution #2 형제 검색 (노드가 루트까지의 길이가 긴 경우)
~~~
만약 트리의 생김새가 길어서 찾는 노드로부터 루트와의 길이가 멀고, 두개의 노드가 근처에 있을 확률이 높을 경우

하나의 노드를 잡고 올라가면서 부모의 자식(Sub Tree)에 자신이 찾는 노드가 있는지 없는지 찾는 방법이다.

만약 부모의 자식(Sub Tree)에 자신이 찾는 노드가 있다면 그 노드가 공통 부모가 되는 것이다.
~~~

## Solution #3 부모 노드가 없을 경우(부모의 주소를 모를 경우)
~~~
#1, #2의 경우 해당 노드의 부모 주소를 알고 있을 경우였기 때문에 위로 올라가면서 찾기가 쉬웠는데

부모의 주소를 모를 경우에는 반대로 루트에서부터 내려오면서 찾는 해결 방법이다.

루트에서부터 a,b가 왼쪽 트리에 있는지, 오른쪽 트리에 있는지 찾고

a,b가 한 쪽에 같이 있으면 해당하는 노드 쪽을 검사하면서 반복적으로 아래로 내려오는 방법이다.
~~~

## Solution #4 최적화
~~~
지금까지의 방법은 루트에서부터 노드를 찾을 때 까지 자식을 전부 다 검사하고 한 번 검사했던 곳을 반복적으로 검사하기 때문에 로직은 알기 쉽지만 비효율적이다.

따라서 postorder(L, R, root)로 모든 노드들을 딱 1번씩만 돌면서 반환 받은 왼쪽과 오른쪽 노드를 보고 양쪽 다 노드를 찾아온 순간을 공통조상으로 반환하는 방법이다.
Postorder란 왼쪽을 우선적으로 검사하고, 왼쪽 검사가 끝나면 오른쪽을 검사한다.

오른쪽까지 검사를 마쳤다면 반환 받은 값을 확인하고 자기 자신과 비교한 뒤, 상황에 따라 부모에게 반환 값을 넘겨준다.

Root를 검사하기 전에 반환 받은 값을 확인하는데
왼쪽 반환 값과 오른쪽 반환 값이 둘 다 Null이면 노드도 못 찾았고, 공통조상도 못 찾은 것이기 때문에 그럴 경우에는 부모에게 자기 자신을 반환한다.

만약 한쪽 반환 값이 Null이고 다른 한쪽이 반환 값이 있다면 부모에게 반환 받은 값을 그대로 반환한다.

~~~

## 시간복잡도
